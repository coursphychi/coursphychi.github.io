<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lunette astronomique afocale â€” Simulation 3D</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif; background: radial-gradient(1200px 600px at 20% 0%, #0b1020, #05070f); color: #e7e9ee; }
    #app { height: 100vh; display: grid; grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
    #overlay { width: 100%; box-sizing: border-box; backdrop-filter: blur(6px); background: rgba(15, 18, 34, 0.6); border: 1px solid rgba(255,255,255,0.08); border-radius: 14px; padding: 12px 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); }
    #overlay h1 { font-size: 16px; margin: 0 0 8px; letter-spacing: 0.3px; font-weight: 700; }
    .control { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 10px; margin: 8px 0; }
    .control label { font-size: 13px; color: #d6d9e0; }
    input[type="range"] { width: 240px; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: nowrap; }
    .btn { appearance: none; border: 1px solid rgba(255,255,255,0.1); background: linear-gradient(180deg, #1e243f, #151a32); color: #eef1f6; padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 13px; letter-spacing: 0.2px; white-space: nowrap; }
    .btn:hover { border-color: rgba(255,255,255,0.25); }
    .small { font-size: 12px; color: #9ca3af; margin-top: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-variant-numeric: tabular-nums; }
    #canvas { position: relative; height: 100%; }
    .legend { position: absolute; bottom: 12px; right: 12px; background: rgba(10,12,22,0.55); border: 1px solid rgba(255,255,255,0.08); padding: 8px 10px; border-radius: 12px; font-size: 12px; }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="app">
    <div id="overlay">
      <h1>Lunette astronomique</h1>
      <div class="control">
        <label for="angle">Angle d'entree theta (deg)</label>
        <input id="angle" type="range" min="-2.8" max="2.8" step="0.01" value="1.0" />
      </div>
      <div class="control">
        <label for="fobj">Focale objectif f<sub>obj</sub> (m)</label>
        <input id="fobj" type="range" min="0.30" max="2.00" step="0.01" value="0.60" />
      </div>
      <div class="control">
        <label for="feye">Focale oculaire f<sub>oc</sub> (m)</label>
        <input id="feye" type="range" min="0.01" max="0.30" step="0.001" value="0.05" />
      </div>
      <div class="control">
        <label>Affichages</label>
        <div class="row">
          <button class="btn" id="toggleMode">Faisceau</button>
          <button class="btn" id="togglePupil">Cercle oculaire</button>
          <button class="btn" id="btnAfocal">Afocal</button>
          <button class="btn" id="resetCam">Recentrer vue</button>
        </div>
      </div>
      <div class="small" id="infoText"></div>
    </div>

    <div id="canvas">
      <div class="legend">Astuce : Alt pour zoomer, glisser pour orbiter. Axe optique = ligne claire (z). Glissez l'oculaire le long de z.</div>
    </div>
  </div>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // Geometry (m)
  let DObj = 0.50;
  let RObj = DObj / 2;
  let REye = 0.05;

  // Optics (variables)
  let fObj = 0.60;
  let fEye = 0.05;
  let sep  = fObj + fEye; // position (z) of eyepiece
  let minSep = 0.30, maxSep = 2.80;

  // Scene
  const container = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);
  const scene = new THREE.Scene();

  // Camera (orthographic default)
  let frustumHeight = 1.3;
  function computeAspect(){ return container.clientWidth / container.clientHeight; }
  let aspect = computeAspect();
  const perspCam = new THREE.PerspectiveCamera(38, aspect, 0.01, 200);
  const orthoCam = new THREE.OrthographicCamera(
    -aspect * frustumHeight / 2,
    aspect * frustumHeight / 2,
    frustumHeight / 2,
    -frustumHeight / 2,
    0.01,
    200
  );
  let activeCam = orthoCam;
  const controls = new OrbitControls(activeCam, renderer.domElement);
  controls.enableDamping = true;

  function setInitialView() {
    const zc = sep * 0.5;
    perspCam.position.set(-2.0, 0.0, zc);
    orthoCam.position.set(-2.0, 0.0, zc);
    controls.target.set(0, 0, zc);
    controls.update();
  }
  setInitialView();

  // Lights & grid
  scene.add(new THREE.HemisphereLight(0xffffff, 0x223344, 0.9));
  const grid = new THREE.GridHelper(6, 30, 0x32435f, 0x1b2742);
  grid.rotation.z = Math.PI / 2; // YZ plane
  grid.position.x = -0.001;
  scene.add(grid);

  // Optical axis (z)
  const axisMat = new THREE.LineBasicMaterial({ color: 0xcfe8ff, transparent: true, opacity: 0.6 });
  let axisLine = null;
  function updateAxisLine() {
    if (axisLine) { scene.remove(axisLine); axisLine.geometry.dispose(); }
    axisLine = line([[0,0,-0.8],[0,0,Math.max(sep+1.4, 1.8)]], axisMat);
    scene.add(axisLine);
  }

  // Lenses (flattened ellipsoids)
  const lensMat = new THREE.MeshPhysicalMaterial({
    color: 0x9fd4ff, roughness: 0.06, metalness: 0.0, transmission: 0.98,
    transparent: true, opacity: 0.78, thickness: 0.2, clearcoat: 1.0, clearcoatRoughness: 0.08
  });

  function makeEllipsoidLens(R, thickness) {
    const geom = new THREE.SphereGeometry(R, 64, 48);
    const mesh = new THREE.Mesh(geom, lensMat);
    const scaleZ = Math.max(0.02, Math.min(0.6, thickness / (2 * R)));
    mesh.scale.set(1, 1, scaleZ);
    const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geom), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 }));
    edges.scale.copy(mesh.scale);
    return { mesh: mesh, edges: edges };
  }

  const L_obj = makeEllipsoidLens(RObj, 0.06);
  L_obj.mesh.position.z = 0.0; L_obj.edges.position.z = 0.0; scene.add(L_obj.mesh, L_obj.edges);
  const L_eye = makeEllipsoidLens(REye, 0.02);

  // Aperture rings
  const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.45, side: THREE.DoubleSide });
  const objRing = ring(RObj, RObj + 0.005, ringMat); objRing.position.z = 0.0; scene.add(objRing);
  const eyeRing = ring(REye, REye + 0.005, ringMat);

  // Eyepiece group
  const eyeGroup = new THREE.Group();
  eyeGroup.add(L_eye.mesh, L_eye.edges, eyeRing);
  eyeGroup.position.z = sep; scene.add(eyeGroup);

  // Drag eyepiece (click strictly on lens)
  const raycaster = new THREE.Raycaster();
  const ndc = new THREE.Vector2();
  const planeX0 = new THREE.Plane(new THREE.Vector3(1,0,0), 0);
  let draggingEye = false;
  let afocalLock = false;

  function setCursor(grabbing) { document.body.style.cursor = grabbing ? 'grabbing' : 'default'; }
  function getNDC(event) {
    const rect = renderer.domElement.getBoundingClientRect();
    ndc.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    ndc.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;
  }
  function pointerDown(e) {
    e.preventDefault();
    getNDC(e);
    raycaster.setFromCamera(ndc, activeCam);
    const inter = raycaster.intersectObject(L_eye.mesh, false);
    if (inter && inter.length) { draggingEye = true; afocalLock = false; controls.enabled = false; setCursor(true); }
  }
  function pointerMove(e) {
    if (!draggingEye) return;
    getNDC(e);
    raycaster.setFromCamera(ndc, activeCam);
    const p = new THREE.Vector3();
    if (raycaster.ray.intersectPlane(planeX0, p)) {
      const zNew = Math.max(minSep, Math.min(maxSep, p.z));
      sep = zNew; eyeGroup.position.z = sep;
      updateAxisLine(); updateFociMarkers(); clampAngleToLimit(); updateInfo(); buildRays(); if (pupilMode) updatePupil();
    }
  }
  function pointerUp() { if (draggingEye) { draggingEye = false; controls.enabled = true; setCursor(false); } }
  renderer.domElement.addEventListener('pointerdown', pointerDown);
  window.addEventListener('pointermove', pointerMove);
  window.addEventListener('pointerup', pointerUp);
  function pointerHover(e){
    if (draggingEye) return;
    getNDC(e);
    raycaster.setFromCamera(ndc, activeCam);
    const inter = raycaster.intersectObject(L_eye.mesh, false);
    document.body.style.cursor = (inter && inter.length) ? 'grab' : 'default';
  }
  renderer.domElement.addEventListener('pointermove', pointerHover);

  // Markers
  const focusOffsetX = 0.004;
  const focusObjMarker = pointMarker(0x42f59e, 0.0016);
  const focusEyeMarker = pointMarker(0xff7bd5, 0.0016);
  scene.add(focusObjMarker, focusEyeMarker);
  const midImageMarker = pointMarker(0xffe369, 0.0014);
  midImageMarker.visible = false; scene.add(midImageMarker);
  function updateFociMarkers() {
    focusObjMarker.position.set( focusOffsetX, 0.0, fObj);
    focusEyeMarker.position.set(-focusOffsetX, 0.0, sep - fEye);
  }

  // Rays groups
  const raysGroup = new THREE.Group(); scene.add(raysGroup);

  // Exit pupil visuals
  let pupilMode = false;
  const pupilVisualGroup = new THREE.Group(); scene.add(pupilVisualGroup);
  let pupilFill = new THREE.Mesh(new THREE.CircleGeometry(0.2, 64), new THREE.MeshBasicMaterial({ color: 0x8fe3ff, transparent: true, opacity: 0.18 }));
  let pupilRing = new THREE.Mesh(new THREE.RingGeometry(0.198, 0.202, 96), new THREE.MeshBasicMaterial({ color: 0xbfe9ff, transparent: true, opacity: 0.8, side: THREE.DoubleSide }));
  pupilVisualGroup.add(pupilFill, pupilRing);
  pupilVisualGroup.visible = false;
  const pupilBeamsGroup = new THREE.Group(); scene.add(pupilBeamsGroup);

  function computeExitPupil() {
    if (sep <= fEye + 1e-5) return null;
    const s_i = (fEye * sep) / (sep - fEye);
    const z_exit = sep + s_i;
    const m = - s_i / sep;
    const R_exit = Math.abs(m) * RObj;
    return { z_exit: z_exit, R_exit: R_exit, m: m, s_i: s_i };
  }
  function clearGroup(g) {
    for (let i=g.children.length-1;i>=0;i--) {
      const ch = g.children[i];
      if (ch.geometry && ch.geometry.dispose) ch.geometry.dispose();
      if (ch.material && ch.material.dispose) ch.material.dispose();
      g.remove(ch);
    }
  }
  function updatePupil() {
    clearGroup(pupilBeamsGroup);
    const ep = computeExitPupil();
    if (!ep) { pupilVisualGroup.visible = false; return; }
    pupilVisualGroup.visible = true;
    pupilVisualGroup.position.set(0,0,ep.z_exit);
    if (pupilFill.geometry) pupilFill.geometry.dispose();
    if (pupilRing.geometry) pupilRing.geometry.dispose();
    pupilFill.geometry = new THREE.CircleGeometry(ep.R_exit, 128);
    pupilRing.geometry = new THREE.RingGeometry(ep.R_exit*0.985, ep.R_exit*1.015, 192);
    const matStrong = new THREE.LineBasicMaterial({ color: 0x93f3ff, transparent: true, opacity: 0.95 });
    const matThin   = new THREE.LineBasicMaterial({ color: 0x93f3ff, transparent: true, opacity: 0.28 });
    const rimCount = 72;
    const ringRadials = [1.0, 0.85, 0.7, 0.55, 0.4, 0.25, 0.1];
    const tail = 0.8;
    for (let i = 0; i < rimCount; i++) {
      const phiR = (2*Math.PI*i)/rimCount;
      const xr = RObj*Math.cos(phiR); const yr = RObj*Math.sin(phiR);
      for (let rIdx = 0; rIdx < ringRadials.length; rIdx++) {
        const rE = ringRadials[rIdx] * REye;
        const spokes = 14;
        for (let s = 0; s < spokes; s++) {
          const phiE = (2*Math.PI*s)/spokes + (rIdx%2 ? Math.PI/spokes : 0);
          const xe = rE*Math.cos(phiE); const ye = rE*Math.sin(phiE);
          const pts = [ new THREE.Vector3(xr, yr, 0), new THREE.Vector3(xe, ye, sep) ];
          const thx = (xe - xr)/sep; const thy = (ye - yr)/sep;
          const thx2 = thx - xe/fEye; const thy2 = thy - ye/fEye;
          const xExit = xe + ep.s_i*thx2; const yExit = ye + ep.s_i*thy2;
          pts.push(new THREE.Vector3(xExit, yExit, ep.z_exit));
          const xTail = xExit + tail*thx2; const yTail = yExit + tail*thy2;
          pts.push(new THREE.Vector3(xTail, yTail, ep.z_exit + tail));
          const geom = new THREE.BufferGeometry().setFromPoints(pts);
          const mat  = (rIdx === 0) ? matStrong : matThin;
          pupilBeamsGroup.add(new THREE.Line(geom, mat));
        }
      }
    }
  }

  // UI refs
  const angleInput  = document.getElementById('angle');
  const fobjInput   = document.getElementById('fobj');
  const feyeInput   = document.getElementById('feye');
  const toggleBtn   = document.getElementById('toggleMode');
  const togglePupilBtn = document.getElementById('togglePupil');
  const btnAfocal   = document.getElementById('btnAfocal');
  const resetBtn    = document.getElementById('resetCam');
  const infoText    = document.getElementById('infoText');

  let mode = 'beam';
  function isAfocalNow() { return Math.abs(sep - (fObj + fEye)) < 1e-3; }
  function updateInfo() {
    const G = Math.abs(fObj / fEye);
    const thetaIn = parseFloat(angleInput.value);
    const cmObj = (fObj * 100).toFixed(1);
    const cmEye = (fEye * 100).toFixed(1);
    const parts = [
      'f_obj=' + cmObj + ' cm',
      'f_oc=' + cmEye + ' cm',
      'G=' + G.toFixed(2),
      'theta_in=' + thetaIn.toFixed(2) + ' deg'
    ];
    if (isAfocalNow()) {
      const thetaOut = - (fObj / fEye) * thetaIn;
      parts.push('theta_out~' + thetaOut.toFixed(2) + ' deg');
    }
    infoText.innerHTML = parts.join(' - ');
  }
  function clampAngleToLimit() {
    const limit = THREE.MathUtils.radToDeg(Math.atan(REye / Math.max(0.001, sep)));
    const val = Math.max(-limit, Math.min(limit, parseFloat(angleInput.value)));
    angleInput.max = limit.toFixed(3);
    angleInput.min = (-limit).toFixed(3);
    angleInput.value = val.toFixed(3);
  }
  function wireUI() {
    toggleBtn.textContent = (mode === 'beam') ? 'Faisceau' : 'Deux rayons';
    function onAngle(){ buildRays(); updateInfo(); }
    angleInput.addEventListener('input', onAngle);
    angleInput.addEventListener('change', onAngle);
    function onFocal(){ updateOpticsFromUI(); }
    fobjInput.addEventListener('input', onFocal);
    fobjInput.addEventListener('change', onFocal);
    feyeInput.addEventListener('input', onFocal);
    feyeInput.addEventListener('change', onFocal);
    toggleBtn.addEventListener('click', function() {
      mode = (mode === 'beam') ? 'two' : 'beam';
      toggleBtn.textContent = (mode === 'beam') ? 'Faisceau' : 'Deux rayons';
      buildRays();
    });
    togglePupilBtn.addEventListener('click', function(){
      pupilMode = !pupilMode;
      if (pupilMode) updatePupil();
      pupilVisualGroup.visible = pupilMode;
      pupilBeamsGroup.visible = pupilMode;
    });
    btnAfocal.addEventListener('click', function(){ setAfocal(); });
    resetBtn.addEventListener('click', function(){ setInitialView(); });
  }

  // Para-axial optics
  function propagate(x, theta, L) { return [x + L * theta, theta]; }
  function thinLens(x, theta, f) { return [x, theta - x / f]; }
  function makeRayPath(x0, y0, thetaY, zStart, zObj, zEye, zEnd) {
    let x = x0, y = y0; let thx = 0.0, thy = thetaY; const pts = [];
    const L0 = zObj - zStart; const xStart = x - L0 * thx; const yStart = y - L0 * thy;
    pts.push(new THREE.Vector3(xStart, yStart, zStart));
    pts.push(new THREE.Vector3(x, y, zObj));
    let t = thinLens(x, thx, fObj); x = t[0]; thx = t[1];
    t = thinLens(y, thy, fObj); y = t[0]; thy = t[1];
    const L1 = zEye - zObj; t = propagate(x, thx, L1); x = t[0]; thx = t[1]; t = propagate(y, thy, L1); y = t[0]; thy = t[1];
    pts.push(new THREE.Vector3(x, y, zEye));
    t = thinLens(x, thx, fEye); x = t[0]; thx = t[1]; t = thinLens(y, thy, fEye); y = t[0]; thy = t[1];
    const L2 = zEnd - zEye; const xEnd = x + L2 * thx; const yEnd = y + L2 * thy;
    pts.push(new THREE.Vector3(xEnd, yEnd, zEnd));
    return pts;
  }
  function computeTwoRayIntersection(angleRad, offset) {
    const y0a = 0.0; const y0b = Math.min(offset, RObj * 0.98); const thy0 = Math.tan(angleRad);
    const thy1a = thy0 - y0a / fObj; const thy1b = thy0 - y0b / fObj; const den1 = (thy1a - thy1b);
    if (Math.abs(den1) < 1e-12) return null;
    const zPre = (y0b - y0a) / den1; const yPre = y0a + zPre * thy1a;
    if (zPre <= sep + 1e-9) { return { z: zPre, y: yPre }; }
    const yEa = y0a + sep * thy1a; const yEb = y0b + sep * thy1b;
    const thy2a = thy1a - yEa / fEye; const thy2b = thy1b - yEb / fEye; const den2 = (thy2a - thy2b);
    if (Math.abs(den2) < 1e-12) return null;
    const zPost = sep + (yEb - yEa) / den2; const yPost = yEa + (zPost - sep) * thy2a; return { z: zPost, y: yPost };
  }
  function buildRays() {
    for (let i = raysGroup.children.length - 1; i >= 0; i--) {
      const child = raysGroup.children[i];
      if (child.geometry && typeof child.geometry.dispose === 'function') child.geometry.dispose();
      if (child.material) {
        if (Array.isArray(child.material)) { for (let m = 0; m < child.material.length; m++) { const mm = child.material[m]; if (mm && typeof mm.dispose === 'function') mm.dispose(); } }
        else if (typeof child.material.dispose === 'function') { child.material.dispose(); }
      }
      raysGroup.remove(child);
    }
    const angleDeg = parseFloat(angleInput.value); const angleRad = THREE.MathUtils.degToRad(angleDeg);
    const zStart = -0.60; const zObj = 0.0; const zEye = sep; const zEnd = zEye + 1.50;
    const matBeam = new THREE.LineBasicMaterial({ color: 0x92d3ff, transparent: true, opacity: 0.9 });
    const matMiss = new THREE.LineBasicMaterial({ color: 0xff7b7b, transparent: true, opacity: 0.35 });
    const matTwoA = new THREE.LineBasicMaterial({ color: 0x7ef7c7, transparent: true, opacity: 0.95 });
    const matTwoB = new THREE.LineBasicMaterial({ color: 0xfdd66b, transparent: true, opacity: 0.95 });
    if (mode === 'beam') {
      midImageMarker.visible = false;
      const rings = 12; const perRing = 48;
      for (let ri = 0; ri <= rings; ri++) {
        const r = RObj * Math.sqrt(ri / rings);
        const nTheta = (ri === 0) ? 1 : perRing;
        for (let k = 0; k < nTheta; k++) {
          const phi = (2 * Math.PI * k) / nTheta; const x0 = r * Math.cos(phi); const y0 = r * Math.sin(phi);
          let x = x0, y = y0, thx = 0.0, thy = Math.tan(angleRad);
          let tx = thinLens(x, thx, fObj); x = tx[0]; thx = tx[1]; let ty = thinLens(y, thy, fObj); y = ty[0]; thy = ty[1];
          tx = propagate(x, thx, sep); x = tx[0]; thx = tx[1]; ty = propagate(y, thy, sep); y = ty[0]; thy = ty[1];
          const hitEye = (x*x + y*y) <= (REye*REye + 1e-9);
          const pts = makeRayPath(x0, y0, Math.tan(angleRad), zStart, zObj, zEye, zEnd);
          const geom = new THREE.BufferGeometry().setFromPoints(pts);
          const lineObj = new THREE.Line(geom, hitEye ? matBeam : matMiss);
          raysGroup.add(lineObj);
        }
      }
    } else {
      const offset = 0.10; // m
      const rays = [ { x0: 0.0, y0: 0.0, mat: matTwoA }, { x0: 0.0, y0: Math.min(offset, RObj * 0.98), mat: matTwoB } ];
      for (let j = 0; j < rays.length; j++) {
        const rdef = rays[j]; const pts2 = makeRayPath(rdef.x0, rdef.y0, Math.tan(angleRad), zStart, zObj, zEye, zEnd);
        const geom2 = new THREE.BufferGeometry().setFromPoints(pts2); const line2 = new THREE.Line(geom2, rdef.mat);
        raysGroup.add(line2); addMarker([rdef.x0, rdef.y0, zObj], 0x7ef7c7);
      }
      const inter = computeTwoRayIntersection(angleRad, offset);
      if (inter && isFinite(inter.z) && isFinite(inter.y)) { midImageMarker.visible = true; midImageMarker.position.set(0, inter.y, inter.z); }
      else { midImageMarker.visible = false; }
    }
    controls.update();
  }
  function addMarker(arr, color) {
    const x = arr[0], y = arr[1], z = arr[2];
    const s = 0.0014;
    const material = new THREE.MeshBasicMaterial({ color: (color || 0xffffff), transparent: true, opacity: 0.95 });
    const m = new THREE.Mesh(new THREE.SphereGeometry(s, 16, 16), material);
    m.position.set(x, y, z); raysGroup.add(m);
  }
  function pointMarker(color, size) {
    const s = size || 0.0014;
    return new THREE.Mesh(new THREE.SphereGeometry(s, 24, 18), new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.95 }));
  }
  function ring(rIn, rOut, mat) { return new THREE.Mesh(new THREE.RingGeometry(rIn, rOut, 64), mat); }
  function line(points, material) {
    const arr = points.map(function(p){ return new THREE.Vector3(p[0], p[1], p[2]); });
    const geom = new THREE.BufferGeometry().setFromPoints(arr);
    return new THREE.Line(geom, material);
  }

  // Afocal & updates
  function updateOpticsFromUI() {
    const wasAfocal = Math.abs(sep - (fObj + fEye)) < 1e-3 || afocalLock;
    fObj = parseFloat(fobjInput.value);
    fEye = parseFloat(feyeInput.value);
    if (wasAfocal) { afocalLock = true; sep = Math.max(minSep, Math.min(maxSep, fObj + fEye)); }
    eyeGroup.position.z = sep;
    updateAxisLine(); updateFociMarkers(); clampAngleToLimit(); updateInfo(); buildRays(); if (pupilMode) updatePupil();
  }
  function setAfocal() {
    sep = Math.max(minSep, Math.min(maxSep, fObj + fEye));
    eyeGroup.position.z = sep;
    afocalLock = true;
    updateAxisLine(); updateFociMarkers(); clampAngleToLimit(); updateInfo(); buildRays(); if (pupilMode) updatePupil();
  }

  // Init
  function init() {
    clampAngleToLimit();
    updateAxisLine(); updateFociMarkers(); updateInfo(); buildRays(); wireUI();
  }
  init();

  renderer.setAnimationLoop(function(){ controls.update(); renderer.render(scene, activeCam); });
  window.addEventListener('resize', function(){
    renderer.setSize(container.clientWidth, container.clientHeight);
    aspect = computeAspect();
    perspCam.aspect = aspect; perspCam.updateProjectionMatrix();
    orthoCam.left = -aspect * frustumHeight / 2; orthoCam.right = aspect * frustumHeight / 2; orthoCam.top = frustumHeight / 2; orthoCam.bottom = -frustumHeight / 2; orthoCam.updateProjectionMatrix();
  });
  </script>
</body>
</html>